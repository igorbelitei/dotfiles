# Aliases and functions for .bashrc
# ====================================

# -------------------------------------------------------
# Prompt / Xterm
# -------------------------------------------------------

# Returns the current git branch.
parse_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

# Returns the current ruby version.
parse_ruby_version() {
  ruby -v | cut -d ' ' -f2
}

# Colored Prompt
force_color_prompt=yes
if [ "$force_color_prompt" = yes ]; then
    PS1="${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\w\[\033[0;36m\] $(parse_git_branch)\[\033[00m\]$ "
else
    PS1="${debian_chroot:+($debian_chroot)}\u@\h:\w\$(parse_git_branch)r\$(parse_ruby_version)$ "
fi
unset color_prompt force_color_prompt

# Custom Xterm Title
case "$TERM" in
xterm*|rxvt*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007";'
    ;;
*)
    ;;
esac

# Bash tab completion
if [ -f /etc/bash_completion ]; then
 . /etc/bash_completion
fi

# Correct spelling errors for 'cd' command, and auto cd to directory
shopt -s cdspell
shopt -s autocd

# Common 'cd' paths
# -------------------------------------------------------
CDPATH=.:~:/opt/rails:/opt/scripts/:/mnt


# -------------------------------------------------------
# Share Bash history across sessions
# -------------------------------------------------------

export HISTSIZE=9000
export HISTFILESIZE=$HISTSIZE
export HISTCONTROL=ignorespace:ignoredups

history() {
  _bash_history_sync
  builtin history "$@"
}

_bash_history_sync() {
  builtin history -a         #[1]
  HISTFILESIZE=$HISTFILESIZE #[2]
  builtin history -c         #[3]
  builtin history -r         #[4]
}

export PROMPT_COMMAND+='_bash_history_sync'


# -------------------------------------------------------
# Aliases (& functions)
# -------------------------------------------------------

# -- bash

alias ll='ls -l --color=auto'
alias rm='trash'
alias n='nautilus .'
alias g='gedit'
# (c)hange directory & list contents
function c() { if [ $1 ]; then cd $1; fi && ll; }
alias ~='cd ~'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

# Include configurable bash aliases, if file exists
if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases; fi

# -- git

alias gs='gst'
alias gc='git commit -m '
alias gca='git commit -am '
alias gpom='git push origin master'
alias pdpreview='git push origin master; cap preview deploy'
alias pdbeta='git push origin master; cap beta deploy'
alias pdlive='git push origin master; cap live deploy'

# -- rvm / ruby / rails

alias s='./script/server -u '
alias cdgem='cd $GEM_HOME/gems'

# This loads RVM into the shell session.
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"


# -------------------------------------------------------
# Custom Functions
# -------------------------------------------------------

# Little calculator function - "$ ? 1337 - 1295" prints "42".
# ===========================================================
? () { echo "$*" | bc -l; }


# Alias management
# ===========================================================

# Adds an alias to ~/.bash_aliases.
# ------------------------------------------------
function add_alias() {
  if [ $1 ] && [ $2 ]; then
    touch ~/.bash_aliases
    echo "alias $1=\"$2\"" >> ~/.bash_aliases
    source ~/.bashrc
  else
    echo "Usage: add_alias <alias> <command>" 
  fi
}
# Adds a change directory alias to ~/.bash_aliases. 
# Use '.' for current working directory.
# Changes directory, then lists directory contents.
# ------------------------------------------------
function add_dir_alias() {
  if [ $1 ] && [ $2 ]; then
    path=`cd $2; pwd`   # Fetches absolute path.
    touch ~/.bash_aliases
    echo "alias $1=\"cd $path; ll\"" >> ~/.bash_aliases
    source ~/.bashrc
  else
    echo "Usage: add_dir_alias <alias> <path>" 
  fi
}
# Remove an alias
# ------------------------------------------------
function rm_alias() {
  if [ $1 ]; then 
    grep -Ev "alias $1=" ~/.bash_aliases > ~/.bash_aliases.tmp
    mv ~/.bash_aliases.tmp ~/.bash_aliases
    unalias $1
    source ~/.bashrc
  else
    echo "Usage: rm_alias <alias>" 
  fi 
}


# Search and replace strings within all files in current dir (recursive).
# =======================================================================
function gsed () {
  if [ -z "$3" ]
  then
    echo "== Usage:    gsed search_string replace_string [path]"
  else
    egrep --exclude-dir=.git -lRZ "$1" $3 | xargs -0 -l sed -i -e "s/$1/$2/g"
  fi
}


# Processes your git status output, exporting bash variables
# for the filepaths of each modified file.
# Written by Nathan D. Broadbent (www.f-77.com)
# =======================================================================
function gst () {
  pfix="e" # Set your preferred shortcut letter here  

  IFS=$'\n '   # Split by newline and space.
  f=0          # Counter for the number of files
  max_changes=15
  
  # Only export variables for less than $max_changes
  if [ `git status --porcelain | wc -l` -lt $max_changes ]; then
    status=`git status --porcelain`   # Get the 'script' version of git status
    c=1 
    for file in $status; do
      # All actions will be on odd lines, all filenames are on even lines.
      let mod=$c%2
      if [ $mod = "0" ]; then
        let f++
        files[$f]=$file        # Array for formatting the output
        export $pfix$f=$file   # Exporting variable for use.
      fi
      let c++
    done
    
    IFS=$'\n'              # Now split only by newline for full git status.
    status=`git status`    # Fetch full status

    # Search and replace each line, showing the exported variable name next to files.
    for line in $status; do   
      i=1
      while [ $i -le $f ]; do
        search=${files[$i]}
        replace="[\$$pfix$i] ${files[$i]}"
        # (fixes a case when a file contains another file as a substring)
        line=${line/$search /$replace }   # Substitution for files with a space suffix.
        line=${line/%$search/$replace}    # Substitution for files with a newline suffix.
        let i++
      done    
      echo $line                        # Print the final transformed line.
    done
  else
    # If there are too many changed files, this 'gst' function will slow down.
    # In this case, fall back to plain 'git status'
    git status
  fi
}


# Adds the current user's public SSH key to the authorized_keys list on a given server.
# =======================================================================
function authorize () {
  if [ $1 ]; then 
    echo "=== Copying and authorizing public key on server..."
    public_key_file=`ls ~/.ssh/id*.pub`
    cat $public_key_file | \
    ssh $1 'cat > /tmp/$USER.pub && mkdir -p ~/.ssh && \
            cat /tmp/$USER.pub >> ~/.ssh/authorized_keys && \
            rm /tmp/$USER.pub'
    echo "===== $USER's public key is now authorized on $1."
  else
    echo "Please specify user@server" 
  fi
}


# -------------------------------------------------------
# Tab Completion for Rake / Capistrano / Thor
# source: https://github.com/sgruhier/rake_cap_bash_autocomplete
# -------------------------------------------------------

export COMP_WORDBREAKS=${COMP_WORDBREAKS/\:/}

_rakecomplete() {
  COMPREPLY=($(compgen -W "`rake -s -T 2>/dev/null | awk '{{print $2}}'`" -- ${COMP_WORDS[COMP_CWORD]}))
  return 0
}

_capcomplete() {
  COMPREPLY=($(compgen -W "`cap  -T  2>/dev/null | awk '{{ if ( $3 ~ /\#/ ) print $2}}'`" -- ${COMP_WORDS[COMP_CWORD]}))
  return 0
}

_thorcomplete() {
  COMPREPLY=($(compgen -W "`THOR_COLUMNS=1000 thor -T 2>/dev/null | awk '{{ if ( $2 ~ /./ ) print $2}}'`" -- ${COMP_WORDS[COMP_CWORD]}))
  return 0
}

complete -o default -o nospace -F _rakecomplete rake
complete -o default -o nospace -F _capcomplete cap
complete -o default -o nospace -F _thorcomplete thor
